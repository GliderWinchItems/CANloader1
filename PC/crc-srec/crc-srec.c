/******************************************************************************
* File Name          : crc-srec.c
* Date First Issued  : 09/02/2022
* Board              : Linux PC
* Description        : Add CRC-32 to end of .srec file
*******************************************************************************/
/*
(NOTE: this program could be greatly streamlined.)

gcc -Wall crc-srec.c crc-32_nib.c -o crc-srec 
gcc -Wall crc-srec.c crc-32_nib.c -o crc-srec && ./crc-srec ../../ldrfixedL431/build/ldrfixedL431
gcc -Wall crc-srec.c crc-32_nib.c -o crc-srec && ./crc-srec /home/deh/GliderWinchItems/BMS/bmsadbms1818/build/bms1818

<name>.xbin file (Extended .bin file)
Bytes
 0 - 3 Program load address (word little endian)
 4 - 7 Program size (bytes) (word little endian)
 8 -11 Program CRC (word little endian)
 12-15 Program checksum (word little endian)
16 - end program bytes
Note: in the xbin file address gaps in the S3 srec are 
  filled with 0xff, whereas the gaps in the .bin file 
  generated by the compiler are filled with zeros.

Sequence:
- Reading srec file generated by compiler
  generate a local bin file
    fill in gaps with 0xff
  copy srec line to output
    generate srec lines for gaps with 0xff

- Compute crc and checksum on local bin file
  generate srec line for crc and checksum
  complete output srec by copying S7 line

 - Generate .xbin file
   load address
   crc including crc at end
   checksum including checksum and end
   binary data 
   crc
   checksum 

*/

#include <stdio.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>
#include <math.h>
#include <time.h>
#include <stdint.h>
#include <stdlib.h>

#include "crc-32_nib.h"

uint8_t gen_gap(void);

#define LINESZ 256 // Max srec line size
char buf[LINESZ];
char bufsav[LINESZ];
char bufsav1[LINESZ];

FILE* fpIn;    // srec input file
FILE* fpBin;   // bin input file
FILE* fpS3out; // srec modified output file
FILE* fpXbin;  // Special bin output file


// Our binary image
uint8_t   bin[1024*1024];
uint8_t* pbin;

// Binary from srec line
struct S3BIN
{
	uint32_t addr;
	uint8_t data[LINESZ];
	uint8_t checksum;
	uint8_t ct;
}s3bin,s3bin_prev;

uint8_t hexbin(char* p);
uint8_t s3cnvt(struct S3BIN* po, char* pi);

// Some counters for debugging
int linect;
int s3ct;
int bct;
int linelen;
int linectout;

char s3fill[96];

int jumpct;

uint32_t loadaddr;

// CRC 
uint32_t crc;	
uint32_t crc2;	
uint32_t crc3;	

// Checksum on binary file
uint64_t binchksum;
uint64_t binchksum3;

// Additonal S3 rec
uint8_t bintmp[64];
char rectmp[96];
uint8_t chktmp;
const char tbl[16] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};

//char *canid_insert = "w";

/* ************************************************************************************************************ */
/*  Yes, this is where it starts.                                                                               */
/* ************************************************************************************************************ */
int main(int argc, char **argv)
{
	int i;
	char ain[96];
	char abin[96];
	char as3out[96];
	char axbin[96];
	uint8_t first_flag = 0;

   /* **********************************************************************************  */
   /* Open files with same name but different extensions                                  */
   /* **********************************************************************************  */
	// .srec generated by compiler
	strncpy (ain,*(argv+1),(96-10));
	strcat (ain,".srec");
	if ( (fpIn = fopen (ain,"r")) == NULL)
	{
		printf ("\nInput .srec file did not open:      %s\n",ain);
		exit (-1);
	}
	printf(".srec file opened read:        %s\n",ain);

	// .bin generated by compiler
	strncpy (abin,*(argv+1),(96-10));
	strcat (abin,".bin");
	if ( (fpBin = fopen (abin,"rb")) == NULL)
	{
		printf ("\nInput .bin file did not open:  %s\n",abin);
		exit (-1);
	}	
	printf(".bin file opened read binary:  %s\n",abin);

	// Modified .srec generated by this program
	strncpy (as3out,*(argv+1),(96-10));
	strcat (as3out,".srec-crc");
	if ( (fpS3out = fopen (as3out,"w")) == NULL)
	{
		printf ("\nOutput .srec-crc file did not open: %s\n",as3out);
		exit (-1);
	}	
	printf(".srec-crc file opened write:   %s\n",as3out);

	// Binary with load address and crc & checksum generated by this program
	strncpy (axbin,*(argv+1),(96-10));
	strcat (axbin,".xbin");
	if ( (fpXbin = fopen (axbin,"wb")) == NULL)
	{
		printf ("\nOutput .xbin file did not open:%s\n",axbin);
		exit (-1);
	}		
	printf(".xbin file opened write binary:%s\n",axbin);

// S3150800000000C00020E54900086D0A0008710A0008CA	

	
	s3ct = 0;
	pbin = &bin[0];
	while ( (fgets (&buf[0],LINESZ,fpIn)) != 0)	// Get a line
	{
		linect += 1;
		linelen = strlen(buf);
		if (linelen < 6) exit(-2);//continue;
//printf("%s",buf);
		if (buf[0] != 'S') continue;
		if (buf[1] == '3')
		{ // Here an S3 line
			s3ct += 1;
			bct = hexbin(&buf[2]);
			if ((bct < 5) || (bct > 128))
			{
				printf("S3 byte ct bad: %d %c%c on line %d\n\r",bct,buf[2],buf[3],linect);
				exit(-3);
			}
			else
			{
				// Convert S3 line to binary
				s3cnvt(&s3bin, buf);

				// Check for a gap in the load addresses
				jumpct = (int)(s3bin.addr - (s3bin_prev.addr+s3bin_prev.ct));

				if (jumpct < 0)
				{ // This should not happend!
					printf("@@@@ ADDRESSES JUMPED BACKWARDS !!! @@@@: 0x%08x - 0x%08X -> %d\n",s3bin.addr,(s3bin_prev.addr+s3bin_prev.ct),jumpct);
				}

				if (jumpct > 0)
				{ // Here addresses have jumped ahead, so fill in gaps.
					/* Initially s3bin.addr will be zero, so the first S3 srec when converted to 
					   binary will show a jump, that is not a gap. */
					if (first_flag == 0)
					{ // Skip the first as it is not a gap.
						first_flag = 1;
						s3bin_prev = s3bin;
						/* The extended binary file had the initial load address. */
						loadaddr = s3bin.addr; // Save for later generation of .xbin file.										
					}
					else
					{ // Add padding to our bin file
printf("GAP:line %5d 0x%08X  0x%08X %d\n\r",linect,(s3bin_prev.addr+s3bin_prev.ct),s3bin.addr,s3bin.addr-(s3bin_prev.addr+s3bin_prev.ct) );	

						/* Generate S3 records that openocd would use to flashing. */
						gen_gap();
						/* Fill in gap in our locally built .bin file. */					
						for (i=0; i < jumpct; i++)
						{ 
							*pbin++ = 0xff; // Our bin data
						}					
					}
				}
				// Copy incoming s3rec to output
				fprintf(fpS3out,"%s",buf);
				linectout += 1; // Output line counter

				// Build a binary
				for (i=0; i < s3bin.ct; i++)
				{ 
					*pbin++ = s3bin.data[i]; // Our bin data
				}
 //printf("%4d %s",bct, buf);
				s3bin_prev = s3bin; // Save converted bin

				// Save in case this is the last s3rec in the input
				strncpy(bufsav1,buf,LINESZ);
			}			
		}
		if (buf[1] == '0')
		{
			fprintf(fpS3out,"%s",buf);
		}

		// Save ending srec line (needed for openocd srec)
		if (buf[1] == '7')
		{
			strncpy(bufsav,buf,LINESZ);
		}

	}
printf("bufsav1: %s\n",bufsav1);

	/* xbin word[0]: load address */
	fwrite((uint8_t*)&loadaddr,1,4,fpXbin);


	/* xbin word[1]: size of bin including crc and checksum at end. */
	uint32_t ourbinsize = pbin - &bin[0];
	if ((ourbinsize & 0x3) != 0)
	{
		printf("######### BIN FILE NOT EVEN WORDS: %5d %0x08X\n",ourbinsize, ourbinsize);
	}
	uint32_t ourbinsize2 = ourbinsize + 8; // Include crc and checksum at end
	fwrite((uint8_t*)&ourbinsize2,1,4,fpXbin);

	printf("Last address s3bin.addr: 0x%08X ct: %d ourbinsize: 0x%08X\n",s3bin.addr,s3bin.ct, ourbinsize);

	/* Compute crc and checksum on binary without appended crc and checksum. */
	int ourbinctr = 0;
	crc2       = ~0L; // Initial CRC value
	binchksum  =  0;  // Checksum
	uint32_t xt;

	for (i = 0; i < ourbinsize/4; i++)
	{
		ourbinctr += 1;
		xt         = *(uint32_t*)&bin[i*4];
		binchksum += xt;//(uint32_t)bin[i];
		crc2 = crc_32_nib_acc(crc2,xt);
	}	
	binchksum3 = binchksum; // Save for further additions

	// Wrap 64b sum into 32b word
	uint32_t tmp  = (binchksum >> 32);
	binchksum = (binchksum & 0xffffffff) + tmp;
	tmp  = (binchksum >> 32);
	binchksum = (binchksum & 0xffffffff) + tmp;

	/* Compute crc and checksum on .xbin =>including<= embedded crc and checksum. */
	crc3 = crc_32_nib_acc(crc2,crc2); // Carry crc2 forward
	binchksum3 += crc2;	// Continue checksum
	crc3 = crc_32_nib_acc(crc3,binchksum);
	binchksum3 += binchksum;

	// Wrap 64b sum into 32b word
	tmp  = (binchksum3 >> 32);
	binchksum3 = (binchksum3 & 0xffffffff) + tmp;
	tmp  = (binchksum3 >> 32);
	binchksum3 = (binchksum3 & 0xffffffff) + tmp;

	// xbin word[2]: crc of binary including appended crc and checksum
	fwrite((uint8_t*)&crc3,1,4,fpXbin);

	// xbin word[3]: checksum of binary including appended crc and checksum
	fwrite((uint8_t*)&binchksum3,1,4,fpXbin);

	// Copy our bin file adding to Xbin file
	for (i = 0; i < ourbinsize/4; i++)
	{
		xt = *(uint32_t*)&bin[i*4];
		fwrite((uint8_t*)&xt,1,4,fpXbin);
	}	

	// Append crc and checksum to bin data sent to node
	fwrite((uint8_t*)&crc2,1,4,fpXbin);
	fwrite((uint8_t*)&binchksum,1,4,fpXbin);


	/*     Comparison check--
	   Read in .bin file generated by compiler and compare 
	     to our local bin file.
	   Where there are gaps in the S3 address, the compiled
	     .bin will have zeros, but our local bin file will 
	     have 0xff. */
	int binfilectr = 0;
	uint8_t bb;
	rewind(fpBin);
	while ( (fread (&bb,sizeof(bb),1,fpBin)) != 0)	// Get a byte
	{
		if ((bb != bin[binfilectr]) )
		{
			printf("BIN DIFF: %5d 0x%02x 0x%02x\n",binfilectr,bb,bin[binfilectr]);
		}
		binfilectr += 1;
	}

	/* Prints for debugging and checking. */
	printf("binfilectr : %5d 0x%08X\n", binfilectr,  binfilectr);
	printf("ourbinsize : %5d 0x%08X\n",ourbinsize , ourbinsize );
	printf("ourbinsize2: %5d 0x%08X\n",ourbinsize2, ourbinsize2);
	printf("ourbinctr  : %5d 0x%08X\n",ourbinctr*4, ourbinctr*4);
	printf(" word ct*4 : %5d binchksum : 0x%08X  crc2: 0x%08X\n",ourbinsize, (unsigned int)binchksum ,(unsigned int)crc2);
	printf(" word ct*4 : %5d binchksum3: 0x%08X  crc3: 0x%08X\n",ourbinsize2,(unsigned int)binchksum3,(unsigned int)crc3);

	/* Check on crc computation. */
	uint32_t crc = crc_32_nib_calc((uint32_t*)&bin[0],ourbinsize/4);//binfilectr/4 );
//	printf("crc: 0x%08X\n",crc);

	/* Generate a S3 rec to store the CRC and checksum */
	// Set load address
	printf("last compile S3 cnt  : %d %X\n\r",s3bin.ct,s3bin.ct);
	printf("last compile S3 addr : 0x%08X\n\r",s3bin.addr);
	s3bin.addr += s3bin.ct;
	printf("Inserted S3 load addr: 0x%08X\n\r",s3bin.addr);
	// Set up bin array
	bintmp[ 0] = 13;
	bintmp[ 1] = s3bin.addr >> 24;
	bintmp[ 2] = s3bin.addr >> 16;
	bintmp[ 3] = s3bin.addr >>  8;
	bintmp[ 4] = s3bin.addr >>  0;
	bintmp[ 5] = crc >>  0;
	bintmp[ 6] = crc >>  8;
	bintmp[ 7] = crc >> 16;
	bintmp[ 8] = crc >> 24;
	bintmp[ 9] = binchksum >>  0;
	bintmp[10] = binchksum >>  8;
	bintmp[11] = binchksum >> 16;
	bintmp[12] = binchksum >> 24;
	char* pr = &rectmp[0];
	*pr++ = 'S';
	*pr++ = '3';
	chktmp = 0;  // Checksum for line
	// Convert to ascii/hex
	for (i = 0; i < 13; i++)
	{
		chktmp += bintmp[i];
		*pr++ = tbl[bintmp[i] >> 4];
		*pr++ = tbl[bintmp[i] & 0x0F];
	}
	chktmp ^= 0xFF;
	*pr++ = tbl[chktmp >> 4];
	*pr++ = tbl[chktmp & 0x0F];
	*pr++ = '\n';
	*pr++ = 0;

	// Append crc & checksum line
	fprintf(fpS3out,"%s",rectmp); 

	// Copy last srec line to modified srec output file
	// This should be the S7 jump srec record.
	fprintf(fpS3out,"%s",bufsav);
	linectout += 2; // Update output line counter

	printf("last srec3 (S7?): %s",bufsav);

	// Some printout for checking purposes. */
	printf ("Inserted S3 line: %s",rectmp);
	printf("bintmp:         ");
	for (i = 0; i < 13; i++)
	{
		printf(" %02X",bintmp[i]);
	}
	printf(" : %02X\n",chktmp);

	/* Check that line checksum etc. is OK. */
	s3cnvt(&s3bin, rectmp);
	printf("Inserted replay: %2d %08X : ",s3bin.ct, s3bin.addr);
	for (i = 0; i < s3bin.ct; i++)
	{
		printf(" %02X",s3bin.data[i]);
	}
	printf(" : %02X\n\r",s3bin.checksum);

	printf ("CRC generated : 0x%08X\n\r",crc);
	printf ("CRC2generated : 0x%08X\n\r",crc2);
	printf ("CRC3generated : 0x%08X\n\r",crc3);
	printf ("Checksum  gen : 0x%08lX\n\r",binchksum);
	printf ("Checksum3 gen : 0x%08lX\n\r",binchksum3);
	printf ("Total line ct : %5d\n\r",linect);
	printf ("Total s3   ct : %5d\n\r",s3ct);
	printf ("Line count out: %5d\n\r",linectout);
	printf ("Size our bin  : %5d 0x%08X\n\r",(int)ourbinctr*4,(int)ourbinctr*4);
	printf ("Size compile b: %5d 0x%08X\n\r",(int)binfilectr,(int)binfilectr);

	fclose(fpIn);
	fclose(fpBin);
	fclose(fpS3out);
	fclose(fpXbin);
	exit(0);
}
/* ********************************************************************************** 
* uint8_t hexbin(char* p);
* @brief    : Convert two hex chars to a binary byte
* @param	: p = pointer to hex char
* @return   : binary value 
* **********************************************************************************  */
uint8_t hexbin_nib(char *p)
{
	if (*p <= '9')
	{
		return *p - '0';
	}
	if (*p < 'a')
		{
			return *p - 'A' + 10;
		}
	return *p - 'a' + 10;
}

uint8_t hexbin(char* p)
{
	return (hexbin_nib(p) << 4) + hexbin_nib(p+1);
}
/* ********************************************************************************** 
* uint8_t s3cnvt(struct S3BIN* po, char* pi);
* @brief    : Convert S3 into binary with checksum check
* @param	: pi = pointer to S3 buffer hex line
* @param    " po = pointer to struct with binary
* @return   : 0 = OK; not 0 = failed
* **********************************************************************************  */
uint8_t s3cnvt(struct S3BIN* po, char* pi)
{
	uint8_t i;
	uint8_t ct = hexbin((pi+2));

	po->ct = ct - 5;
	po->checksum = 0x00;

	// 0000000000111111111122222222223333333333444444
    // 0123456789012345678901234567890123456789012345  
	// S3150800000000C00020E54900086D0A0008710A0008CA
/*	
0000000000111111111122222222223333333333444444
0123456789012345678901234567890123456789012345  
S31508005E3847455420464C41534850206164647220B3 */
	po->addr  = hexbin((pi + 4)) << 24;
	po->addr |= hexbin((pi + 6)) << 16;
	po->addr |= hexbin((pi + 8)) <<  8;
	po->addr |= hexbin((pi +10)) <<  0;

	po->checksum += hexbin((pi + 2));
	po->checksum += hexbin((pi + 4));
	po->checksum += hexbin((pi + 6));
	po->checksum += hexbin((pi + 8));
	po->checksum += hexbin((pi +10));

//printf("%08X : ",po->addr);

	for (i = 0; i < ct-5; i++)
	{
		po->data[i] = hexbin((pi+12+2*i));
		po->checksum += po->data[i];
//printf(" %02X", po->data[i]);	
	}
	po->checksum ^= 0xff;
	uint8_t check = hexbin((pi+12+2*i));
//printf(" : %02X %02X\n\r",po->checksum,check);
	if (check != po->checksum)
	{
		printf("BAD CHECK:%02X %02X at line in: %d line out: %d: %s",po->checksum,check,linect,linectout,pi);
		return 1;
	}
	return 0;
}
/* ********************************************************************************** 
* uint8_t gen_gap(uint32_t* pstart, uint23_t pend);
* @brief    : Convert S3 into binary with checksum check
* @param	: pstart
* @param    " pend
* @return   : 0 = OK; not 0 = failed
* **********************************************************************************  */
void makeline(uint8_t n)
{
	int i;
	uint8_t crc3 = 0;
	char* pr = &s3fill[0];

	// Set up bin array: byte ct, address
	bintmp[ 0] = n+5;
	bintmp[ 1] = s3bin_prev.addr >> 24;
	bintmp[ 2] = s3bin_prev.addr >> 16;
	bintmp[ 3] = s3bin_prev.addr >>  8;
	bintmp[ 4] = s3bin_prev.addr >>  0;

	/* Convert to ascii/hex and build checksum, */
	*pr++ = 'S';
	*pr++ = '3';
	// Byte count, address
	for (i = 0; i < 5; i++)
	{
		crc3 += bintmp[i];
		*pr++ = tbl[bintmp[i] >> 4];
		*pr++ = tbl[bintmp[i] & 0x0F];		
	}
	// Add data
	for (i = 0; i < n; i++)
	{
		crc3 += 0xFF;
		*pr++ = 'F';
		*pr++ = 'F';
	}
	crc3 ^= 0xFF; // Complete checksum
	// Add checksum
	*pr++ = tbl[crc3 >> 4];
	*pr++ = tbl[crc3 & 0x0F];
	*pr++ = '\n';
	*pr++ = 0;

	/* Update previous address and ct */
	s3bin_prev.addr += n;
	s3bin_prev.ct = n;

	// Output srec	
	fprintf(fpS3out,"%s",s3fill);
	linectout += 1; // Output line counter

//printf("%5d 0x%08X %s",linectout, s3bin_prev.addr,s3fill);
	return;
}
/* ********************************************************************************** 
* uint8_t gen_gap(void);
* @brief    : Generate S3 records to bridge an address jump gat
* **********************************************************************************  */
uint8_t gen_gap(void)
{
	// Number bytes in the gap
	int32_t ct = jumpct;
	if (ct < 1)
	{
		printf("@@@@ NEG GAP @@@@: %d\n",ct);
		exit(-9);
	}
printf("BEGIN GAP GEN: 0x%08x  0x%08x %d\n\r",s3bin.addr,s3bin_prev.addr,ct);
	s3bin_prev.addr += s3bin_prev.ct;

	while (ct > 8)
	{
		makeline(8);
		ct -= 8;
		printf("LOOP  GAP GEN: 0x%08x  0x%08x %d\n\r",s3bin.addr,s3bin_prev.addr,ct);

	} 
	if (ct > 0) // Complete remainder, if any
	{
		makeline(ct);
		printf("REMAINDER GEN: 0x%08x  0x%08x %d\n\r",s3bin.addr,s3bin_prev.addr,ct);

	}
	return 0;
}
